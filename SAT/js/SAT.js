/**
* @see http://www.dyn4j.org/2010/01/sat/
* @see http://www.gamedev.net/page/resources/_/technical/game-programming/swept-aabb-collision-detection-and-response-r3084
* Technically my second attempt in implementing the Separating axis test.
* This function assumes the objects passed in have a property that's an array called 'vertices' with a series of objects that represent 
* the polygon's vertices originating from the object's center.
* Assumes polygon is clockwise
*/
function SATTest (polygonA, polygonB, options) {
	var 
	axis,
	axesA = [],
	axesB = [],
	axes = [],
	i = 0,
	projectionA,
	projectionB,
	overlapMin,
	overlapMax,
	overlap,
	mtvInfo = {
		magnitude: undefined,
		axis: undefined,
		source: undefined
	},
	vectorMath = {
		/**
		* @function subtract
		* @description Subtracts vectorB from vectorA and returns the difference
		* @param {object} vectorA
		* 	@param {number} vectorA.x
		* 	@param {number} vectorA.y
		* @param {object} vectorB
		* 	@param {number} vectorB.x
		* 	@param {number} vectorB.y
		* @returns {object} A vector that represents the difference between vectorA and vectorB
		*/
		subtract: function (vectorA, vectorB) {
			return {
				x: vectorA.x - vectorB.x, 
				y: vectorA.y - vectorB.y
			};
		},
		/**
		* @function perpendicular
		* @description Returns the given vector's perpendicular vector, since the polygon is generated by clockwise vertices, x and y is flipped, with the new y being negative.
		* @param {object} vector Vector to make perpendicular
		* 	@param {number} vector.x
		* 	@param {number} vector.y
		* @returns {object} The vector perpendicular to the given vector
		*/
		perpendicular: function (vector) {
			return {
				x: -vector.y, 
				y: vector.x
			};
		},
		negate: function(vector) {
			return {
				x: -vector.x,
				y: -vector.y
			}
		},
		normalize: function (vector) {
			var length = Math.sqrt(Math.pow(vector.x, 2) + Math.pow(vector.y, 2));
			return {x: 
				vector.x / length, 
				y: vector.y / length
			};
		},
		dot: function (vectorA, vectorB) {
			return (vectorA.x * vectorB.x) + (vectorA.y * vectorB.y);
		},
		cross: function(vectorA, vectorB) {
			return (vectorA.x * vectorB.y) - (vectorA.y * vectorB.x);
		}
	};
	
	/**
	* @function getAxes
	* @description Gets all axes in a given polygon
	* @param {object} polygon Polygon to get axes from
	* 	@param {number} polygon.vertices An array of objects with x and y parameters that represent vertices that make up the polygon
	* @returns {array} An array of axes for the given polygon
	*/
	function getAxes(polygon) {
		var axes = [],
		vertices = polygon.vertices,
		vertexA,
		vertexB,
		i = 0;
		
		// Get axis for each edge in the polygon (order of vertices do matter!)
		for (i = 0; i < vertices.length; i++) {
		
			vertexA = vertices[i];
			vertexB = vertices[i + 1 == vertices.length ? 0 : i + 1];
			
			// Get the edge vector
			// Get the normal of the edge vector
			// Normalize the normal
			axes.push(vectorMath.normalize(vectorMath.perpendicular(vectorMath.subtract(vertexA, vertexB))));
			 
		}
		
		return axes;
	}
	
	/** 
	* @function getProjection 
	* @description Gets the projection of a polygon upon a given axis
	* @param {object} polygon Polygon to project
	* 	@param {number} polygon.vertices An array of objects with x and y parameters that represent vertices that make up the polygon
	* @param {object} axis Axis to project upon
	* 	@param {number} axis.x X coordinate of the axis vector
	*	@param {number} axis.y Y coordinate of the axis vector
	* @returns {object} object that represents the min and max values of the polygon projected on a given axis
	*/
	function getProjection(polygon, axis) {
		var vertices = polygon.vertices,
		dot,
		min,
		max,
		i = 0;
		
		for(i = 0; i < vertices.length; i++) {

			dot = vectorMath.dot(axis, vertices[i]);
			
			if(typeof min === 'undefined' && typeof max === 'undefined') {
				min = dot;
				max = dot;
			} else if(dot < min)
				min = dot;
			else if(dot > max)
				max = dot;
			
		}
		
		return {min: min, max: max};
		
	}
	
	/**
	* @function checkProjectionOverlap 
	* @description Checks for overlap between two projections
	* @param {object} projectionA
	* 	@param {number} projectionA.min Min value of projection
	* 	@param {number} projectionA.max Max value of projection
	* @param {object} projectionB
	* 	@param {number} projectionB.min Min value of projection
	* 	@param {number} projectionB.max Max value of projection
	* @returns {number|boolean} A number representing the overlap, false otherwise
	*/
	function checkProjectionOverlap(projectionA, projectionB) {
		var overlap;
		
		// After projection B or before projection B (No overlap)
		if(projectionA.min > projectionB.max || projectionA.max < projectionB.min)
			return false;
		
		// Projections are within each other
		// Return the overlap amount
		return Math.abs(Math.min(projectionA.max, projectionB.max) - Math.max(projectionA.min, projectionB.min));
		
	}
	
	/**
	* A contains B... Or B contains A
	*/
	function checkProjectionContainment(projectionA, projectionB) {
		return (projectionA.min >= projectionB.min && projectionA.max <= projectionB.max) || (projectionB.min >= projectionA.min && projectionB.max <= projectionA.max);
	}

	// Get all axes from both polygons
	axesA = getAxes(polygonA); // Used to determine whose axes the MTA comes from
	axesB = getAxes(polygonB);
	axes = axesA.concat(axesB);
		
	// Loop through all axes
	for (i = 0; i < axes.length; i++) {
		axis = axes[i];
		
		projectionA = getProjection(polygonA, axis);
		projectionB = getProjection(polygonB, axis);
		
		overlap = checkProjectionOverlap(projectionA, projectionB)
		
		// Exit check as soon as projection check returns false
		if(typeof overlap !== 'number')
			return false;
		else {
			
			// Note: dyn4j mentions that whichever is smaller, be prepared to negate/flip the axis
			if(checkProjectionContainment(projectionA, projectionB)) {
				overlapMin = Math.abs(projectionA.min - projectionB.min);
				overlapMax = Math.abs(projectionA.max - projectionB.max);
				
				overlap += overlapMin < overlapMax ? overlapMin : overlapMax;
			}
			
			
			if(typeof mtvInfo.magnitude === 'undefined' || overlap < mtvInfo.magnitude) {
				mtvInfo = {
					magnitude: overlap,
					axis: axis,
					origin: i >= axesA.length ? polygonB : polygonA
				};
			}
		}
	}

	return mtvInfo;
	
}